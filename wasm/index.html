<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Wascal on Wasm</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style type="text/css">
            body {
                color: #000000;
                text-align:center;

                background-color: #f0f0f0;
                margin: 0px;
                width: 100%;
            }
            .code {
                font-family:Monospace;
                font-size:15px;
            }
            .justify {
                text-align: justify;
                padding: 2em;
            }
            .leftAlign {
                text-align: left;
                padding: 1em;
            }
            .border {
                border: solid black 2px;
                margin: 0.5em 2em 0.5em 2em;
                padding: 0.5em;
            }
        </style>
    </head>
    <body>
        <h1>Wascal on Wasm</h1>
        <hr>
        <div>
            Samples: <span id="samples"></span>
        </div>
        <div class="code">
            <textarea  id="input" type="text" cols="120" rows="20" ></textarea>
        </div>

        <div>
            <button id="parseAst">Parse AST</button>
            <button id="disasm">Disassemble</button>
            <button id="compile">Compile</button>
        </div>

        <div id="timeMessage"></div>

        <div class="border">
            <h3>Function List</h3>
            <div id="functions" class="leftAlign"></div>
        </div>

        <div class="code">
            <textarea  id="console" type="text" readonly cols="120"  rows="20" ></textarea>
        </div>

        <h2>Canvas:</h2>
        <div><button id="clearCanvas">Clear</button></div>
        <canvas id="canvas" width="320" height="320" style="border: solid 1px black"> </canvas>

        <div class="justify">
            <h2>Data types</h2>
            WebAssembly has only 4 primitive types.
            You can declare variables and function arguments in a syntax like <tt>a: type</tt>
            or <tt>let f(a: type) -> type</tt>.
            <tt>type</tt> can be one of:
            <ul>
                <li>i32</li>
                <li>i64</li>
                <li>f32</li>
                <li>f64</li>
            </ul>

            <p>
            Yes, there are no string types!
            Since we do not use linear memory yet, we can't handle variable length data, including a string.
            </p>

            <h2>Built-in functions</h2>

            <ul>
            <li>log(value: i32) - Prints a value to JavaScript console (console.log).</li>
            <li>putc(char: i32) - Puts a single character, specified by ascii code, to the output console.</li>
            <li>set_fill_style(r: i32, g: i32, b: i32) - Sets fill color for painting on the canvas.</li>
            <li>rectangle(x: i32, y: i32, width: i32, height: i32) - Draws a filled rectangle on the canvas.</li>
            </ul>

            <h2>Syntax</h2>
            The syntax is inspired a bit by functional languages, although the execution model is imperative.
            <h3>Variable declaration</h3>
            <p>
                Variables are declared with <tt>let</tt> keyword like below.
            </p>

            <pre>
let x: i32 = 42;
            </pre>

            <p>
            If the type is omitted, the type is inferred.
            However, note that the variable has to be constrained by an expression somewhere in the function, otherwise
            the type inference fails with an ambiguous type.
            So the function below is ok:
            </p>

            <pre>
let f() -> i32 = {
    let x = 42;
    x
}
            </pre>

            <p>
            but the one below is not, because its type is not bounded by any expression.
            </p>

            <pre>
let f() -> i32 = {
    let x = 42;
    0
}
            </pre>

            <h3>Cast expression</h3>
            You can cast a type to another with <tt>as</tt> keyword:

            <pre>
pub let as_i32(x: f64) -> i32 = x as i32;
            </pre>

            <h3>Function definition</h3>
            <p>
            Functions are declared with <tt>let</tt> keyword too, but it can have parameters in parentheses.
            </p>

            <pre>
let add(x: i32, y: i32) -> i32 = x + y;
            </pre>

            <p>
            Types of the parameters are required, although this requirement may be lifted in the future.
            If the return type is omitted, it is inferred from the last expression in the function body.
            </p>

            <p>
            You can put <tt>pub</tt> keyword in front of a function definition to denote exported functions from Wasm module.
            Please note that if you don't put <tt>pub</tt>, it won't be visible from the environment thus not directly callable.
            </p>

            <pre>
pub let main() = add(1, 2);
            </pre>

            <h3>Brace statement</h3>
            <p>
            Braces can group multiple statements together.
            You can use it as the container of a function body made of multiple statements, although you don't have to
            if your function is entirely made of a single expression.
            The value of the statement is the last statement in the brace.
            </p>

            <pre>
pub let main(x) = {
    log(x + 42);
    42
}
            </pre>

            <h3>If expression</h3>
            Conditional branching is done by <tt>if</tt> expression.
            Each branch can contain multiple statements and yields the last statement's value like a brace statement.

            <pre>
let abs(x) = if x &lt; 0 { -x } else { x };
            </pre>

            <h3>For statement</h3>
            <tt>for</tt> statement looks like Rust's, but you need to put start and end indices as <tt>start to end</tt>.
            <tt>start</tt> and <tt>end</tt> indices must be i32.
            You can put multiple statements in <tt>for</tt> statement,
            but the last statement is not used, unlike <tt>if</tt> expression.

            <pre>
for i in 1 to x {
    log(i);
}
            </pre>

            <p>
            You can <tt>break</tt> in a statement.
            </p>

            <pre>
for i in 1 to x {
    if 10 &lt; i {
        break
    };
}
            </pre>

            <h3>Return statement</h3>
            Return statement lets you exit the function early.

            <pre>
let mandelconverge(creal: f64, cimag: f64) -> i32 = {
    let r: f64 = creal;
    let i: f64 = cimag;
    for iter in 0 to 255 {
        if r*r + i*i > 4. {
            return iter;
        };
        let next_r: f64 = r * r - i * i + creal;
        i = 2. * r * i + cimag;
        r = next_r;
    }
    iter
}
            </pre>

            <h2 id="Time">Time measurement resolution</h2>
            Due to security reasons, your browser may have reduced time resolution for measurement.
            It is typically 0.1ms or 1ms, but can be larger.
            Please be aware that the lower digits may be always 0 because of this rounding.
            See <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now#reduced_time_precision">this page</a> for details.
        </div>

        <hr>
        <p>Source on <a href="https://github.com/msakuta/wascal">GitHub</a>.</p>

    </body>
</html>
