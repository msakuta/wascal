
struct Vec3 {
    x: f64,
    y: f64,
    z: f64,
}

let __add__(lhs: Vec3, rhs: Vec3) = Vec3 {
    x: lhs.x + rhs.x,
    y: lhs.y + rhs.y,
    z: lhs.z + rhs.z,
}

let __sub__(lhs: Vec3, rhs: Vec3) = Vec3 {
    x: lhs.x - rhs.x,
    y: lhs.y - rhs.y,
    z: lhs.z - rhs.z,
}

let dot(lhs: Vec3, rhs: Vec3) -> f64 = lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;
let length2(v: Vec3) -> f64 = dot(v, v);
let normalize(v: Vec3) -> Vec3 = {
    let leng: f64 = sqrt(length2(v));
    Vec3 { x: v.x / leng, y: v.y / leng, z: v.z / leng }
}

let format_vec3(s: Vec3) -> str = "(" + format_f64(s.x) + ", " + format_f64(s.y) + ", " + format_f64(s.z) + ")";

let hit_sphere(obj: Vec3, radius: f64, src: Vec3, dir: Vec3, dt: f64) -> f64 = {
    let del = src - obj;

    let b = dot(dir, del);

    let dirslen = length2(dir);
    let c = dirslen * (length2(del) - radius * radius);

    let discrim = b * b - c;
    if discrim > 0. {
    } else {
        return -1.;
    };

    let d = sqrt(discrim);

    if 0. < dirslen {
        let t0 = (-b - d) / dirslen;
        let t1 = (-b + d) / dirslen;
        if t1 < 0. {
            -1.
        } else {
            t0
        }
    } else {
        -1.
    }
}

pub let main() -> void = {
    let ray_source = Vec3 { x: 0., y: 0., z: 0. };
    let sphere = Vec3 { x: 0., y: 0., z: -10. };
    let light = Vec3 { x: 0.5, y: 1., z: 1. };
    let radius: f64 = 5.;
    let pixels: i32 = 16;
    let width: i32 = 8;
    for y in -pixels to pixels {
        let _: i32 = y;
        for x in -pixels to pixels {

            let ray = normalize(Vec3 { x: x as f64 / pixels as f64, y: y as f64 / pixels as f64, z: -1. });

            let hit_f = hit_sphere(sphere, radius, ray_source, ray, 50.);

            if 0. < hit_f {
                putc(32)
            } else if y < 0 {
                putc(46)
            } else {
                putc(42)
            };

        }
        putc(10);
    }
}